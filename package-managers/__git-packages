#!/usr/bin/env bash

subcommand="$1"
shift

# package name = name of the repo and thus the directory in $GIT_PACKAGES
# package identifier = <github username>/<package name>
# host-package identifier = <hostname>/<package identifier>

function get_hostname_from_url_or_package_identifier() {
  local input="$1"
  if [[ $input == http* ]]; then
    input="${input#https://}"
    echo "${input#http://}" | cut -d '/' -f 1
  elif [[ $input == */*/* ]]; then
    echo "$input" | cut -d '/' -f 1
  else
    echo "github.com"
  fi
}

function get_git_url_from_any() {
  local host_package_ident
  host_package_ident="$(get_host_package_identifier_from_any "${1:?}")"
  if [[ $host_package_ident == *.localhost*/*/* ]]; then # for now we can be pretty sure that only .localhost domains are http
    echo "http://$host_package_ident"
  else
    echo "https://$host_package_ident"
  fi
}


function get_host_package_identifier_from_any() {
  local input="$1"
  input="${input#https://}"
  input="${input#http://}"
  input="${input%.git}"
  input="${input%/}"
  if [[ $input == */*/* ]]; then # already a host package identifier
    echo "$input" 
  else
    get_package_path "$input" | rev | cut -d '/' -f 1-3 | rev
  fi
}

function get_package_path() {
  local input="$1"
  input="${input#https://}"
  input="${input#http://}"
  input="${input%.git}"
  input="${input%/}"
  find "$GIT_PACKAGES" -type d -path "*/${input:?}" -print -quit
}

function upgrade_build_strategy_path() {
  echo "$XDG_DATA_HOME/upkg/git-packages/run-on-upgrade/$(get_host_package_identifier_from_any "${1:?}")"
}

case "$subcommand" in
"test-existence")
  [[ -d "$GIT_PACKAGES" ]] || exit 1
  ;;
"list")
  for hostnamepath in "$GIT_PACKAGES"/*; do
    for ownerpath in "$hostnamepath"/*; do
      for packagepath in "$ownerpath"/*; do
        echo "$(basename "$hostnamepath")/$(basename "$ownerpath")/$(basename "$packagepath")"
      done
    done
  done
  ;;
"list-version") # version of a git package is the short hash of the current commit, since packages with actual releases and thus version are handled by `stew`
  for hostnamepath in "$GIT_PACKAGES"/*; do
    for ownerpath in "$hostnamepath"/*; do
      for packagepath in "$ownerpath"/*; do
        (
          cd "$packagepath" || exit 1
          echo "$(basename "$hostnamepath")/$(basename "$ownerpath")/$(basename "$packagepath")@$(git rev-parse --short HEAD)"
        )
      done
    done
  done
  ;;
"listable-name")
  get_host_package_identifier_from_any "$1"
  ;;
"install")
  (
    package="$(cut -d "@" -f 1 <<<"$1")"
    version="$(cut -d "@" -f 2 <<<"$1")"
    host_package_identifier="$(get_host_package_identifier_from_any "${package:?}")"
    cd "$GIT_PACKAGES" || exit 1
    echo "Cloning package repository $host_package_identifier ..."
    if [[ -d "$host_package_identifier" ]]; then
      echo "package already installed: $host_package_identifier"
      exit 1
    fi
    mkdir -p "$(dirname "$host_package_identifier")"
    git clone "$(get_git_url_from_any "${package:?}")" "$host_package_identifier" || exit 1
    cd "$host_package_identifier" || exit 1
    if echo "$1" | grep -q @; then
      git checkout "$version" || exit 1
    fi
    $0 build "$host_package_identifier"
  )
  ;;
"remove")
  package_path="$(get_package_path "$1")"
  echo "Removing package at $package_path ..."
  if [[ -d "$package_path" ]]; then
    rm -rf "$package_path"
  else
    echo "package not installed: $package_path" >&2
    exit 1
  fi
  ;;
"upgrade")
  package_path="$(get_package_path "$1")"
  host_package_identifier="$(get_host_package_identifier_from_any "$1")"
  echo "Upgrading package at $package_path ..."
  if [[ -d "$package_path" ]]; then
    (cd "$package_path" && git checkout -- . && git pull) || exit 1

    if [[ -f "$(upgrade_build_strategy_path "$host_package_identifier")" ]]; then
      upgrade_strategy="$(cat "$(upgrade_build_strategy_path "$host_package_identifier")")"
    else
      echo "No upgrade strategy found. Default to 'always'"
      upgrade_strategy="always"
    fi

    should_run=false

    case "$upgrade_strategy" in
      "always")
        should_run=true
        ;;
      "ask-yes")
        ask "Do you want to run the install script?" Y && should_run=true
        ;;
      "ask-no")
        ask "Do you want to run the install script?" N && should_run=true
        ;;
      "never")
        should_run=false
        ;;
      *)
        echo "Unknown upgrade strategy: $upgrade_strategy" >&2
        exit 1
        ;;
    esac

    if [[ "$should_run" = true ]]; then
      $0 build "$host_package_identifier"
    fi
  else
    echo "package not installed: $package_path" >&2
    exit 1
  fi
  ;;
"upgrade-all")
   for hostnamepath in "$GIT_PACKAGES"/*; do
    for ownerpath in "$hostnamepath"/*; do
      for packagepath in "$ownerpath"/*; do
        $0 upgrade "$(basename "$hostnamepath")/$(basename "$ownerpath")/$(basename "$packagepath")"
      done
    done
  done
  ;;
"which")
  (
    package_path="$(get_package_path "${1:?}")"
    if [[ -d "$package_path" ]]; then
      echo "$package_path"
    else
      echo "package not installed: $package_path" >&2
      exit 1
    fi
  )
  ;;
"build")
  package_path="$(get_package_path "${1:?}")"
  package_name="$(basename "$package_path")"
  host_package_identifier="$(get_host_package_identifier_from_any "$1")"
  echo "Building package $host_package_identifier ..."
  install_script_path="$XDG_DATA_HOME/upkg/git-packages/install/$host_package_identifier"
  if [[ -f "$install_script_path" ]]; then
    echo "Install script found."
  else
    echo "Generating install script..."
    [[ -f "$package_path/$package_name" ]] && package_executable="$package_path/$package_name"
    [[ -f "$package_path/build.zig" ]] && build_zig="$package_path/build.zig"

    # Check for files and store them in arrays
    package_executable=""
    build_zig=""
    declare -a makefiles
    declare -a install_scripts

    [[ -f "$package_path/$package_name" ]] && package_executable="$package_path/$package_name"
    [[ -f "$package_path/build.zig" ]] && build_zig="$package_path/build.zig"
    for file in GNUmakefile makefile Makefile; do
      [[ -f "$package_path/$file" ]] && makefiles+=("$file")
    done
    for file in "$package_path"/install*; do
      [[ -f "$file" ]] && install_scripts+=("$file")
    done

    # Generate hint text dynamically
    link_hint=$([[ -n "$package_executable" ]] && echo "(executable with same name as package found)")
    zig_hint=$([[ -n "$build_zig" ]] && echo "(build.zig found)" || echo "(no build.zig found!)")
    make_hint=$([[ ${#makefiles[@]} -gt 0 ]] && echo "(makefiles found: ${makefiles[*]})")
    install_script_hint=$([[ ${#install_scripts[@]} -gt 0 ]] && echo "(install scripts found: ${install_scripts[*]})")

    while true; do
      # Ask user for install strategy
      echo "Select install strategy:"
      options=(
        "1) none"
        "2) link $link_hint"
        "3) build with zig $zig_hint"
        "4) run install script $install_script_hint"
        "5) make $make_hint"
        "6) run a custom script"
      )
      strategy_choice=$(printf '%s\n' "${options[@]}" | fzf --prompt="Enter choice: ")
      if [[ -z "$strategy_choice" ]]; then
        ask "No choice made. Do you want to cancel & exit?" Y && exit 1
      else
        ask "You chose $strategy_choice, is that correct?" Y && break 2
      fi
    done

    # Check if the user made a choice
    if [[ -z "$strategy_choice" ]]; then
      echo "No choice made. Exiting..."
      exit 1
    fi

    # Extract the strategy index from the choice
    strategy_index=$(printf '%s\n' "${options[@]}" | grep -nxF "$strategy_choice" | cut -d: -f1)

    install_code="#!/usr/bin/env bash\n\n"
    skip_edit=false

    case "$strategy_index" in
      "1") # none
        echo "Don't install anything. Empty script generated. Done, exiting..."
        skip_edit=true
        ;;
      "2") # link
        if [[ -n "$package_executable" ]]; then
          if ask "Executable with same name as package found. Do you want add linking it to the install script?" Y; then
            read -rp "Rename to (optional, leave empty to not rename): " rename_to
            target="$HOMEBIN/${rename_to:-$package_name}"
            install_code+="ln -sf \"$package_executable\" \"$target\"\n"
            install_code+="chmod +x \"$target\"\n"
          fi
        fi
        if [[ -z "$package_executable" ]] || ask "Do you want to link something else?" N; then
          # Loop to select executables
          while true; do
            echo "Select a file to link:"
            linkme=$( ( { cd "$package_path" || exit; } | tree -L 3 -if --noreport | cut -d / -f '2-' | tail -n '+2' | fzf --prompt="Select a file to link: ") )
            read -rp "Rename to (optional, leave empty to not rename): " rename_to
            target="$HOMEBIN/${rename_to:-$linkme}"
            install_code+="ln -sf \"$package_path/$linkme\" \"$target\"\n"
            install_code+="chmod +x \"$target\"\n"
            ask "Do you want to link something else?" N || break
          done
        fi
        ;;
      "3") # zig
        read -rp "Additional build args (optional, leave empty to not use any): " build_args
        install_code+="zig build install --prefix \"$HOME/.local\" $build_args\n"
        ;;
      "4") # install-script
        # Loop to select install scripts
        if [[ "${#install_scripts[@]}" -gt 0 ]]; then
          if ask "Install scripts found. Do you want to add them to the main install script?" Y; then
            for script in "${install_scripts[@]}"; do
              read -rp "Additional args for $script (optional): " args
              install_code+="chmod +x \"$script\"\n"
              install_code+="$script $args\n"
            done
          fi
        fi
        if [[ "${#install_scripts[@]}" -eq 0 ]] || ask "Do you want to add a/another script to the main install script?" N; then
          # Loop to select install scripts
          while true; do
            echo "Select a script to run:"
            script=$( ( { cd "$package_path" || exit; } | tree -L 3 -if --noreport | cut -d / -f '2-' | tail -n '+2' | fzf --prompt="Select a script to run: " ) )
            read -rp "Additional args (optional): " args
            install_code+="chmod +x \"$package_path/$script\"\n"
            install_code+="$package_path/$script $args\n"
            ask "Do you want to run something else?" N || break
          done
        fi
        ;;
      "5") # make
        # if there is only one makefile, use it
        makefile=""
        if [[ ${#makefiles[@]} -eq 1 ]]; then
          makefile="${makefiles[0]}"
        else
          # select makefile
          echo "Select a makefile to use:"
          select selectedmakefile in "${makefiles[@]}"; do
            makefile="$selectedmakefile"
            break
          done
        fi
        install_code+="make -C \"$package_path\" -f \"$makefile\" install\n"
        ;;
      "6") # run
        # No additional code needed
        ;;
    esac

    # Save generated install script
    mkdir -p "$(dirname "$install_script_path")"
    echo -e "$install_code" > "$install_script_path"
   
    if [[ "$skip_edit" = true ]]; then
      exit 0
    fi

    # Ask user to edit the install script
    ask "Install script generated. Do you want to edit the script?" N && $VISUAL "$install_script_path"

  fi

  # Ask user what strategy we should choose when upgrading: always, ask-yes, ask-no, never

  if ! [[ -f "$(upgrade_build_strategy_path "$host_package_identifier")" ]] && ask "Do you want to set an upgrade strategy?" Y; then
    while true; do
      echo "Select upgrade strategy:"
      options=(
        "1) always"
        "2) ask-yes"
        "3) ask-no"
        "4) never"
      )
      strategy_choice=$(printf '%s\n' "${options[@]}" | fzf --prompt="Enter choice: " | cut -d ' ' -f '2-')
      if [[ -z "$strategy_choice" ]]; then
        ask "No choice made. Do you want to cancel & exit?" Y && exit 1
      else
        ask "You chose $strategy_choice, is that correct?" Y && break 2
      fi
    done

    mkdir -p "$(dirname "$(upgrade_build_strategy_path "$host_package_identifier")")"
    echo "$strategy_choice" > "$(upgrade_build_strategy_path "$host_package_identifier")"
  fi
  chmod +x "$install_script_path"
  # Run the install script
  "$install_script_path"
  ;;
"delete-install-script")
  host_package_identifier="$(get_host_package_identifier_from_any "$1")"
  install_script_path="$XDG_DATA_HOME/upkg/git-packages/install/$host_package_identifier"
  if [[ -f "$install_script_path" ]]; then
    rm "$install_script_path"
  else
    echo "No install script found for $host_package_identifier"
  fi
  ;;
"delete-upgrade-strategy")
  host_package_identifier="$(get_host_package_identifier_from_any "$1")"
  upgrade_strategy_path="$(upgrade_build_strategy_path "$host_package_identifier")"
  if [[ -f "$upgrade_strategy_path" ]]; then
    rm "$upgrade_strategy_path"
  else
    echo "No upgrade strategy found for $host_package_identifier"
  fi
  ;;
"package-manager")
  echo "git-packages (no independent existence)"
  ;;
"package-manager-version")
  echo "0.0.0"
  ;;
"which-self")
  echo "$GIT_PACKAGES"
  ;;
"install-self")
  mkdir -p "$GIT_PACKAGES"
  ;;
"help")
  cat <<EOF
NAME

  git-packages - a subcommand of upkg, managing git packages

SYNOPSIS

  upkg git-packages [subcommand] [arguments...]

DESCRIPTION

  git-packages is a subcommand of upkg that provides an interface to manage git packages. It takes a subcommand as its first argument, and further arguments as subsequent arguments.

SUBCOMMANDS

  test-existence: Checks if the GIT_PACKAGES directory exists.

  list: Lists all git packages installed in the GIT_PACKAGES directory.

  list-version: Lists installed git packages with their current version (commit hash).

  listable-name: Gets the name of a package as used in \`list\` and related commands.

  install <package identifier|URL>: Installs a specific git package. 

  remove <package identifier|URL|name>: Removes a specific git package.

  upgrade <package identifier|URL|name>: Upgrades a specific git package to the latest commit on the default branch.

  upgrade-all: Upgrades all installed git packages to the latest commit on their default branches.

  which <package identifier|URL|name>: Returns the location of a specific git package. The argument can be a package identifier, the URL, or the name of the git repository.

  link <package name> [executable_name] [rename_to]: Creates a symbolic link to an executable file in the package directory. Requires the package name and optionally the executable name and a new name for the executable.

  package-manager: Prints the package manager name.

  package-manager-version: Prints the version of the package manager.

  which-self: Returns the path to the GIT_PACKAGES directory.

  install-self: Creates the GIT_PACKAGES directory if it doesn't exist.

  help: Prints the help message.

NOTES

  version is the short hash of the current commit, since packages with actual releases and thus version are handled by stew.
  package identifier is the package identifier in the format <username>/<repository name>.
EOF
  ;;
esac
