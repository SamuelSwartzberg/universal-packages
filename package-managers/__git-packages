#!/usr/bin/env bash

subcommand="$1"
shift

# package name = name of the repo and thus the directory in $GIT_PACKAGES
# package identifier = <host>/<github username>/<package name>
# package url = https://github.com/<package identifier>[.git]

function get_hostname_from_url_or_package_identifier() {
  local input="$1"
  if [[ $input == http* ]]; then
    echo "${input#https://}" | cut -d '/' -f 1
  elif [[ $input == */*/* ]]; then
    echo "$input" | cut -d '/' -f 1
  else
    echo "github.com"
  fi
}

function get_git_url_from_package_identifier_or_url() {
  local hostname="$(get_hostname_from_url_or_package_identifier "$1")"
  echo "https://${hostname}/$(get_package_identifier_from_url_or_package_identifier "${1:?}")"
}


function get_package_identifier_from_url_or_package_identifier() {
  local input="$1"
  local hostname="$(get_hostname_from_url_or_package_identifier "$input")"
  input="${input#https://}"
  input="${input#"$hostname"/}"
  input="${input%.git}"
  echo "$input"
}

function get_package_path() {
  local package_identifier
  if echo "${1:?}" | grep -q /; then # is a package identifier
    package_identifier="$(get_package_identifier_from_url_or_package_identifier "${1:?}")"
    echo "${GIT_PACKAGES:?}/${package_identifier:?}"
  else # is a package name, so we need to use `find` to get the package identifier
    find "${GIT_PACKAGES:?}" -type d -name "${1:?}" -print -quit
  fi
}

case "$subcommand" in
"test-existence")
  [[ -d "$GIT_PACKAGES" ]] || exit 1
  ;;
"list")
  for hostname in "$GIT_PACKAGES"/*; do
    for owner in "$hostname"/*; do
      for package in "$owner"/*; do
        echo "$hostname/$owner/$package"
      done
    done
  done
  ;;
"list-version") # version of a git package is the short hash of the current commit, since packages with actual releases and thus version are handled by `stew`
  for hostname in "$GIT_PACKAGES"/*; do
    for owner in "$hostname"/*; do
      for package in "$owner"/*; do
        (
          cd "$package" || exit 1
          echo "$hostname/$owner/$package@$(git rev-parse --short HEAD)"
        )
      done
    done
  done
  ;;
"install")
  (
    package="$(cut -d "@" -f 1 <<<"$1")"
    version="$(cut -d "@" -f 2 <<<"$1")"
    package_identifier="$(get_package_identifier_from_url_or_package_identifier "${package:?}")"
    cd "$GIT_PACKAGES" || exit 1
    if [[ -d "$package_identifier" ]]; then
      echo "package already installed: $package_identifier"
      exit 1
    fi
    mkdir -p "$(dirname "$package_identifier")"
    git clone "$(get_git_url_from_package_identifier_or_url "${package:?}")" "$package_identifier" || exit 1
    cd "$package_identifier" || exit 1
    if echo "$1" | grep -q @; then
      git checkout "$version" || exit 1
    fi
    upkg git-packages build "$package_identifier"
  )
  ;;
"remove")
  package_path="$(get_package_path "$1")"
  if [[ -d "$package_path" ]]; then
    rm -rf "$package_path"
  else
    echo "package not installed: $package_path" >&2
    exit 1
  fi
  ;;
"upgrade")
  package_path="$(get_package_path "$1")"
  if [[ -d "$package_path" ]]; then
    (cd "$package_path" && git pull)
  else
    echo "package not installed: $package_path" >&2
    exit 1
  fi
  ;;
"upgrade-all")
  for package in "$GIT_PACKAGES"/*/*/*; do
    (cd "$package" && git pull)
  done
  ;;
"which")
  (
    package_path="$(get_package_path "${1:?}")"
    if [[ -d "$package_path" ]]; then
      echo "$package_path"
    else
      echo "package not installed: $package_path" >&2
      exit 1
    fi
  )
  ;;
"build")
  package_path="$(get_package_path "$1")"
  package_name="$(basename "$package_path")"
  cd "$package_path" || exit 1
  if [[ -f ./install.sh ]]; then
    ./install.sh
  elif [[ -x /"$package_name" ]]; then
    ask "executable found with same name as package, link?" N && upkg git-packages link "$package_name" "$package_name"
  elif [[ -f ./Makefile ]]; then
    ask "Makefile found, run make?" N && make install
  elif [[ -f ./build.zig ]]; then
    ask "build.zig found, run zig build?" N && zig build install --prefix "$HOME/.local"
  else
    ask "package has no install script or makefile: $1, do you want to link an executable instead?" N && upkg git-packages link "$package_name"
  fi
  ;;
"link") # args: package_name, executable_name, rename_to (optional)
  if [[ -z "$1" ]]; then
    echo "missing arguments"
    echo "usage: upkg git-packages link package_name [executable_name]"
    exit 1
  fi
  package_path="$(get_package_path "$1")"
  executable_name="$2"
  if [[ -z "$executable_name" ]]; then
    executable_name="$(select dir in $(ls "$package_path"); do
      echo "$dir"
      break
    done)"
  fi

  read -rp "rename to (optional): " rename_to

  chmod +x "$package_path"/"$executable_name"
  ln -sf "$package_path"/"$executable_name" "$HOMEBIN/${rename_to:-$executable_name}"
  ;;
"package-manager")
  echo "git-packages (no independent existence)"
  ;;
"package-manager-version")
  echo "0.0.0"
  ;;
"which-self")
  echo "$GIT_PACKAGES"
  ;;
"install-self")
  mkdir -p "$GIT_PACKAGES"
  ;;
"help")
  cat <<EOF
NAME

  git-packages - a subcommand of upkg, managing git packages

SYNOPSIS

  upkg git-packages [subcommand] [arguments...]

DESCRIPTION

  git-packages is a subcommand of upkg that provides an interface to manage git packages. It takes a subcommand as its first argument, and further arguments as subsequent arguments.

SUBCOMMANDS

  test-existence: Checks if the GIT_PACKAGES directory exists.

  list: Lists all git packages installed in the GIT_PACKAGES directory.

  list-version: Lists installed git packages with their current version (commit hash).

  install <package identifier|URL>: Installs a specific git package. 

  remove <package identifier|URL|name>: Removes a specific git package.

  upgrade <package identifier|URL|name>: Upgrades a specific git package to the latest commit on the default branch.

  upgrade-all: Upgrades all installed git packages to the latest commit on their default branches.

  which <package identifier|URL|name>: Returns the location of a specific git package. The argument can be a package identifier, the URL, or the name of the git repository.

  link <package name> [executable_name] [rename_to]: Creates a symbolic link to an executable file in the package directory. Requires the package name and optionally the executable name and a new name for the executable.

  package-manager: Prints the package manager name.

  package-manager-version: Prints the version of the package manager.

  which-self: Returns the path to the GIT_PACKAGES directory.

  install-self: Creates the GIT_PACKAGES directory if it doesn't exist.

  help: Prints the help message.

NOTES

  version is the short hash of the current commit, since packages with actual releases and thus version are handled by stew.
  package identifier is the package identifier in the format <username>/<repository name>.
EOF
  ;;
esac
